---
layout: post
has_code: true
category: vocation
category_fa: تخصصی
title: 'مرورگرها چگونه کار می‌کنند؟'
tags: [learning, reference, frontend, browsers, html, css, webkit, firefox, chrome]
---

{% post_summary %}
مرورگرهای وب پر استفاده ترین نرم افزاری هستند که تا به حال به دست بشر ساخته شده‌اند. به همین خاطر می‌خواهیم سفر اکتشافی داشته باشیم به اعماق این موجودات تا ببینیم چه اتفاقی در پس پرده‌ی آن‌ها در حال رخ دادن است.
{% endpost_summary %}

{% container %}
##مقدمه

مرورگرهای اینترنتی، نقش چشمان و حالا حتی، ادراک حسی ما را در هنگام گشت و گذار در اینترنت بازی می‌کنند. محتوای آن‌ها، صفحات وب و برنامه‌های تحت وبی هستند که  در نتیجه تلاش مداوم توسعه دهندگان وب ایجاد می‌شود. وجود این ابزار به همان اندازه‌ای که برای مصرف کنندگان این محتوا حیاتی است، برای تولید کنندگانش نیز حیاتی است.

در هر عرصه‌ای، از صنعت گرفته تا هنر، از دیرباز، مرز باریکی بین خلاقیت و تقلید و تکرار منفعلانه 
بوده است. در این میان، تنها افرادی که توانسسته‌اند از این مرز بگذرند، نام‌شان در طول تاریخ جاودان مانده است. پیش نیاز خلاقیت و ابداع، درک و فهم عمیق است. هر چقدر این درک نسبت به اصول اولیه، ابزار و فنون بالاتر رود، جسارت تغییر و نوآوری هم بالاتر می‌رود.

استاد کاری که نتواند ابزار کار خود را به حد کفایت بشناسد، ناخواسته به بردگی آن تن خواهد داد؛ و در صورت عکس ماجرا، این ابزار است که رام استاد کار خواهد شد و تحت کنترل آن در خواهد آمد. حال هر چه تسلط یک توسعه دهنده‌ی وب بر روی این مرورگرها بیشتر باشد، با جسارت بیشتری می‌تواند دست به طراحی و تخلیل بزند؛ و نیز در مواجه با چالش‌های گوناگون، راحت‌تر می‌تواند از سد آن‌ها بگذرد.

در طول سال‌های متمادی که IE سهم نود درصدی از میزان استفاده از مرورگرها را در دست داشت، چیز زیادی از آن‌ها نمی‌دانستیم و به صورت یک جعبه‌ی سیاه باقی مانده بودند. اما بعد از ورود شکوهمندانه‌ی مرورگرهای متن باز و حالا با کسب بیش از ۷۵ درصدی سهم مرورگرها، زمان مناسبی رسیده بود تا سرکی به پشت پرده‌ی موتورهای این مرورگرها بیندازیم و ببینیم چه چیزی در میان آن چند میلیون خط کد C++ در جریان است... 

مایه‌ی اصلی وجودی متن پیش رو، بر اساس تحقیقات توسعه دهنده‌ی اسراییلی‌، خانوم Tali Garsiel، که در [سایت](http://taligarsiel.com/) خود منتشر کرده‌اند زده شده است. در بعضی از قسمت‌ها که به نظرم رسیده نیاز به عمیق شدن به آن شدتی که ایشان شده اند، نبوده؛ من راه خودم را از ایشان جدا کرده ام و سعی کردم یک شرح مختصر از کلیات آن قسمت داشته باشم. در انتهای این بخش‌ها به همان قسمت از مقاله‌ی اصلی ارجاع داده‌ام تا دوستان علاقمند بتوانند راحت تر به عمق‌های بعدی نفوذ کنند.

###به اعماق کدوم مرورگرها دقیقا می‌خواییم سفر کنیم؟

در حال حاضر ۵ مرورگر اصلی که در سیستم عامل‌های رومیزی استفاده می‌شوند عبارتند از: کروم، فایرفاکس، اینترنت اگسپلورر، سافاری و اُپرا. در سیستم عامل‌های همراه نیز مرورگرهای اصلی عبارتند از: مرورگر اندروید، آیفون، ویندوز فون، اُپرا مینی، اُپرا موبایل، مرورگر UC، مرورگرهای s40/s60 نوکیا و کروم - که همه آنها به جز مرورگرهای ویندوز فون و اپرا بر اساس موتور WebKit پیاده سازی شده اند.

متن پیش رو بر اساس مرورگرهای اوپن سورس فایرفاکس، کروم و سافاری(که بخشی‌هایی از آن اوپن سورس است) تنظیم شده است. در حال حاضر این مرورگرها به شهادت آمار سایت [StatCounter](http://gs.statcounter.com/) ] چیزی حدود ۷۰ تا ۷۵ درصد سهم بازار مصرف مرورگرها در دسکتاپ و موبایل را در اختیار دارند.

###یک مرورگر از چه اجزایی تشکیل شده است؟

اجزایی اصلی  یک مرورگر عبارتند از:

1. **رابط کاربری (UI)**: این لایه شامل آدرس باز، دکمه‌های عقب و جلو، منوی بوکمارک و غیره است. تمام بخش‌های ظاهری مرورگر و چیزهای که در هنگام در خواست نمایش سک ثفحه وب به مرورگر می‌دهد به جز قالب پنجره‌ی آن(همان سه، چهار دکمه‌ای که در گوشه‌ی بالایی سمت راست یا چپ کادر در بر گیرنده‌ی مرورگر خود می‌بینید) را شامل می‌شود.
2. **موتور مرورگر**: مسول اصلی رسیدگی به عملیات‌های صورت گرفته بین لایه‌های UI و موتور رندر هستند ایشان. می‌توانید ایشان را پلیس راهنمایی رانندگی سر چهار راه ولیعصر نیز متصور شوید.
3. **موتور رندر**: مسولیت نمایش محتوای درخواست شده بر عهده‌ی ایشان است. برای مثال اگر محتوای درخواست شده یک سند HTML باشد، موتور رندر کدهای HTML و CSS مربوطه را بعد از تجزیه کردن (Parse) بر روی صفحه نمایش کاربر، همان طور که در حال حاضر در حال خواندن این جملات هستید، نمایش می‌دهد.
4. **شبکه**: مسول عملیات‌های شبکه‌ای مانند یک در خواست HTTP است. ایشان علاوه بر اینکه خود یک رابط(Interface) مستقل از پلتفرم هستند، از پیاده سازی‌های مختلفی نیز در پلتفرم‌های مختلف در لایه‌های پایین‌تر استفاده می‌کنند.
5. **بستر رابط کاربری (UI backend)**: به منظور رسم و نمایش عناصری مثل کومبو باگس‌ها و پنجره ها استفاده می‌شوند. این لایه هم مثل لایه‌ی شبکه از یک رابط عمومی بهره می‌برد که مختص پلتفرم خاصی نیست؛ ولی در آن سطوح پایین از متدهای رابط کاربری مختص همان پلتفرم هم استفاده می‌کند.
6. **مترجم جاوا اسکریپت**: همان طور که از اسمش مشخص است وظیفه‌ی تجزیه و اجرای کدهای جاوا اسکریپت را بر عهده دارد.
7. **انباره داده‌ها (Data Storage)**: این لایه وظیفه‌ی نگهداری از تمامی انواع داده‌های مرورگر از قبیل، کوکی‌ها، Session-ها وغیره را بر عهده دارد. و نیز عهده دار مدیریت مکانیزم‌های دیگر نگهداری و پالایش داده‌ها نظیر LocalStorage، IndexedDB، WebSQL و FileSystem نیز هست.

{% figure caption:"اجزای اصلی مرورگرها" %}
![اجزای اصلی مرورگرها](/assets/images/content/2015/12/browser-components.png)
{% endfigure %}


این نکته‌ی مهمی است که به خاطر داشته باشید که مرورگرهای مانند کروم، نمونه‌های (Instance) متعدد از موتور رندر خود را اجرا می‌کنند. یعنی برای هر تب، یک موتور رندر؛ که هر تب فرآیند(Process) جداگانه‌ی خود را دارد. (می‌توانید با فشار دادن همزمان کلیدهای ترکیبی shift+Esc در مرورگر کروم خود به راحتی فرآیند‌های در حال اجرا توسط آن را مشاهده کنید.)

##موتور رندر

همان طور که قبلا اشاره شد، مسولیت موتور رندر، رندر کردن است؛ که این می‌شود نمایش محتوای درخواست شده از سمت کاربر نهایی، درون پنجره‌ی مرورگر.

به طور پیش فرض موتورهای رندر کننده‌ی قادر هستند تا سندهای HTML، XML و تصاویر را نمایش دهند. البته آن‌ها علاوه بر این قسم از منابع، قادرند اسناد PDF و غیره را نیز به واسطه‌ی نصب پلاگین‌های مربوطه نمایش دهند. در هر صورت در این فصل تماماْ بر روی نحوه‌ی رندر و نمایش اسناد HTML‌ و تصاویر که به وسیله‌ی CSS آرایش شده‌اند، تمرکز خواهیم کرد.

###موتورهای رندر کننده

مرورگرهای مختلف، از موتورهای رندر کننده‌ی مختلفی نیز استفاده می‌کنند. به طوری که:

+ اینترنت اگسپلورر: Trident
+ فایرفاکس: Gecko
+ سافاری: WebKit
+ کروم و اُپرا (از نسخه‌ی ۱۵): ‌Blink (شاخه‌ای از وب‌کیت است که توسط گوگل منشعب شده)

استفاده می‌کنند.

وب‌کیت یک موتور رندر کننده‌ی متن باز است که در ابتدا به منظور استفاده در پلتفرم لینوکس کلید خورد و بعد‌ها توسط شرکت اپل به منظور استفاده در پلتفرم‌های مک و ویندوز ویرایش شد. برای جزییات بیشتر می‌توایند به [وب سایت](https://webkit.org/) خود این موتور که به تازگی هم باز طراحی شده مراجعه کنید.

###فرآیند اصلی رندر یک صفحه‌ی HTML

موتور رندر کننده کار خودش را درست از زمانی آغاز می‌کند که محتوای درخواست شده توسط لایه‌ی شبکه، از سرور تحویل گرفته شده باشد. این اطلاعات به طور معمولی در قطعات ۸ کیلوبایتی از سمت سرور تحویل داده می‌شوند.

پس از رسیدن داده‌ها، موتور رندر چهار مرحله‌ای را که در تصویر زیر مشاهده می‌کنید را به ترتیب برای هر درخواست در هر بار باید طی کند تا سند درخواستی کاربر برایش در پنچره مرورگر قابل مشاهده و استفاده شود.

{% figure caption:"جریان اصلی عملیات انجام شده توسط موتور رندر مرورگر" %}
![جریان اصلی عملیات انجام شده توسط موتور رندر مرورگر](/assets/images/content/2015/12/rendering-engine-basic-flow.png)
{% endfigure %}

موتور رندر کننده با تجزیه و تبدیل سند HTML‌ به گره‌های(node) درختی به نام «درخت محتوا» کار خود را آغاز می‌کند. موتور همچنین داده‌های مربوط به استایل(stylesheet) این گره‌ها را نیز تجزیه می‌کند که شامل تمامی انواع استایل‌ها، از خارجی(external) گرفته تا درونی(inline) می‌شود. این اطلاعات بدست آماده از تجزیه داده‌های استایل‌ها به همراه دستورات بصری آمده در سند HTML توسط موتور برای ساخت یک درخت دیگر به نام «درخت رندر» استفاده می‌شود.

درخت رندر، شامل مستطیل‌هایی است که مشخص کننده‌ی مختصات هر عنصر در صفحه و خصوصیات آنها مانند رنگ، نوع و اندازه قلم و غیره است. این مستطیل‌ها درست به ترتیبی که قرار است این عناصر بر روی صفحه نمایش نقش ببندند بر روی درخت از بالا به پایین چیده می‌شوند.

بعد ساخته شدن درخت رندر، موتور به سراغ فرآیند ایجاد لایه‌ی (layout) عناصر می‌رود. به این معنی که به هر یک از گره‌های درخت رندر که هر کدام در نهایت عناصر تشکیل دهنده‌ی صفحه وب خواهند بود، نسبت به اندازه و مختصات دیگر گره‌های درخت رندر، یک مختصات (طول و عرض و عمق) مخصوص داده می‌شود که باید دقیقا بر اساس آن بر روی صفحه ظاهر شوند.

مرحله‌ی بعدی رنگ آمیزی (painting) است. هر کدام از گره‌های درخت رندر در اینجا به وسیله‌ی لایه‌ی بستر رابط کاربری (UI backend) رنگ و لعاب داده می‌شود. یعنی همان ظاهری خارجی که ما بر روی صفحه نمایش می‌توانیم به عنوان خروجی ببینیم، در این مرحله صورت می‌پذیرد.

این نکته مهم است که در نظر داشته باشید که این چهار مرحله گفته شده، یک فرآیند پیش رونده تدریجی و بلادرنگ است. به این معنی که به خاطر ایجاد یک تجربه کاربری خوب برای کاربر، موتور رندر سعی می‌کند که به محض آماده شدن اولین سری از داده‌ها از سمت سرور و دریافت آن‌ها، فرآیند رندر را شروع کند؛ و به انتظار دریافت کامل اطلاعات نماند. در این شیوه موتور رندر هر بخش از کدهای HTML‌ که به دستش می‌رسد را شروع به تجزیه می‌کند و باقی مراحل را بر روی آن انجام می‌دهد تا به مرحله نمایش در صفحه نمایش برسد. این عمل را تا جایی ادامه می‌دهد که به انتهای کد‌های HTML‌ دریافتی برسد.

###مثال‌های شماتیک از فرآیند اصلی رندر

{% figure caption:"فرآیند اصلی رندر در موتور وب‌کیت" %}
![فرآیند اصلی رندر در موتور وب‌کیت](/assets/images/content/2015/12/WebKit-engine-main-flow.png)
{% endfigure %}

{% figure caption:"فرآیند اصلی رندر در موتور Gecko موزیلا" %}
![فرآیند اصلی رندر در موتور Gecko موزیلا](/assets/images/content/2015/12/firefox-engine-main-flow.jpg)
{% endfigure %}

همان طور که در دو تصویر فوق می‌بینید، دو موتور وب‌کیت و گِکو تفاوت مختصری از نظر لغوی دارند و عملا فرآیند اصلی در هر دو یکسان است.

گِکو درخت عناصری که مشخصات ظاهریشان تعیین شده است را «درخت فریم (Frame tree)» می‌نامند؛ و هر به عنصر یا گره‌ی درخت یک فریم می‌گویید. این در حالی است که همانطور که گفته شد وب‌کیت به این درخت، «درخت رندر» می‌گویید که تشکیل شده از «اشیای رندر (Render Objects)». در جای دیگر هم وب کیت از اصطلاح «لایه (layout)» برای مشخص کردن مختصات عناصر در صفحه می‌کند؛ در حالی که گِکو آن را «جانمایی (reflow)» می‌نامند.

وب‌کیت از اصطلاح «ضمیمه (Atachment)» برای مرحله‌ای که گره‌های DOM‌ را با خصوصیات بصری استخراجی از CSS می‌خواهد ترکیب کند، استفاده می‌کند. یک تفاوت غیر معنایی(لغوی) جزیی در اینجا این است که گِکو یک لایه اضافه بین داده‌های تجزیه شده‌ی HTML و درخت DOM دارد که آن را «سینک محتوا (content sink)» (همان سینک ظرفشویی خودمان) می‌نامد که به صورت یک کارخانه با خط تولید عناصر DOM عمل می‌کند. در ادامه به تفصیل درباره‌ی تمامی بخش‌ها صحبت خواهیم کرد.

##تجزیه HTML و تشکیل درخت DOM

###تجزیه (Parsing): کلیات
نویسنده در مقاله‌ی [منبع](http://taligarsiel.com/Projects/howbrowserswork1.htm) برای اینکه بتواند یکی خصوصیات ذاتی زبان HTML را توضیح دهد، بر آن شده تا به طور کامل و تفصیلی به این مبحث تجزیه و تبدیل کدهای خام HTML بپردازد. ولی به نظر من برای یک توسعه دهنده‌ی وب حتی در سطح حرفه‌ای، که بیشتر هدفش ساخت صفحات وب است؛ نه بهبود عملکرد مرورگرها و یا الگوریتم تجزیه‌ی HTML  تا این حد پرداختن به جزییات ضرورتی ندارد و من در ادامه این بخش تنها به باز گویی کلیاتی از آنچه که در مقاله اصلی آمده است بسنده می‌کنم. دوستانی که تمایل دارند تا به طور کامل در جریان چند و چون کار قرار گیرند می‌توانند به [این](http://taligarsiel.com/Projects/howbrowserswork1.htm#Parsing_general) بخش از مقاله منبع مراجعه کنند.

تجزیه کردن بیشتر به معنای ترجمه کردن است. به این معنی که ما بیایم یک سند و متنی را که بر اساس یک گرامر معین تنظیم شده است به یک سری ساختار قابل فهم برای ماشین که به آن زبان ماشین نیز گفته می‌شود تجزیه و ترجمه کنیم. نتیجه‌ی این ترجمه معمولا یک درختی از گره‌هایی است که نشان دهنده‌ی ساختار آن سند هستند؛ که به آن درخت تجزیه یا درخت نحو (syntax) نیز می‌گویند.

برای مثال، تجزیه‌ی عبارت 1 - 3 + 2  به صورت درخت زیر می‌تواند در بیاید:

{% figure caption:"اگره‌های درخت تجزیه شده‌ی یک عبارت ریاضی" %}
![اگره‌های درخت تجزیه شده‌ی یک عبارت ریاضی](/assets/images/content/2015/12/basic-parsing-mathematical-expression-tree-node.png)
{% endfigure %}

#### گرامرها 
تجزیه کردن بر اساس قواعد نحوی صورت می‌پذیرد که از پیش برای هر زبانی تعیین شده است. هر فرمتی که قرار است تجزیه شود باید دارای یک گرامر قطعی که متشکل از دایره‌ی واژگان آن زبان و قواعد نحوی آن است، باشد. جالب است بدانید که زبان‌های انسانی، جز این زبان‌ها نیستند و بنابراین نمی‌توان آن‌ها را با تجزیه کنندگان معمولی که داریم تجزیه و تبدیل کنیم.

#### ترکیب پارسر-لِگزر
عمل تجزیه کردن را می‌توان به ۲ زیر بخش اصلی زیر تقسیم کرد:

1. آنالیز لغوی
2. آنالیز نحوی

آنالیز لغوی به فرآیندی اطلاق می‌شود که در آن داده‌های ورودی به اجزای کوچکتری شکسته می‌شوند که به آن‌ها علامت‌های رمزی یا توکن (Token) می‌گویند. این توکن‌ها همان لغات زبان‌ها هستند. آنالیز نحوی نیز همان طور که از اسمش مشخص است از بر اساس قواعد نحوی و گرامری زبان سنجیده و استخراج می‌شود.

مسولیت عملیات تجزیه بر عهده‌ی دو بخش مجزا است. **lexer** (به خوانید لِگزر) (که گاهی هم به آن tokenizer می گویند) مسول شکستن داده‌های ورودی به توکن‌های معتبر است و بخش دیگر **parser** نام دارد که مسؤل ساخت درخت تجزیه بر پایه‌ی قواعد نحویی زبانی است که داده‌های ورودی با آن تنظیم شده‌اند. لِگزرها به اندزه‌ای هوشمند هستند که کارکترهای زايد مانند فاصله‌ها و خط شکن‌ها را تشخیص دهند.

{% figure caption:"مراحل تبدیل یه سند ورودی به درخت تجزیه شده" %}
![مراحل تبدیل یه سند ورودی به درخت تجزیه شده](/assets/images/content/2015/12/from-source-document-to-parse-trees.png)
{% endfigure %}

تجزیه کردن، یک فرآیند چرخشی و تکرار شونده است. تجزیه‌گر معمولا از لِگزر برای یک توکن جدید درخواست می‌دهد و می‌گردد به دنبال قاعده‌ی نحوی مطابق با آن تُکِن. اگر با قاعده‌ای مطابق بود که گره‌ای را بر روی درخت تجزیه به آن اختصاص می‌دهد و دوباره یک تُکن جدید درخواست می‌کند.

در صورتی که هیچ قاعده‌ی نحوی مطابق با تُکن یافت نشود، تجزیه‌گر آن را به صورت یک تُکن داخلی ذخیره می‌کند؛ و به درخواست تُکن‌های بعدی ادامه می‌دهد تا زمانی که قواعد مربوط به تمامی تُکن‌های ذخیره شده به صورت داخلی هم پیدا شود. اگر تُکنی در این مرحله هم بدون قاعده ماند، تجزیه‌گر اعلام خطا می‌کند. این بدان معنی است که سند ورودی معتبر نیست و در بر گیرنده‌ی قواعد نحوه‌ی اشتباه است.

#### ترجمه

در بسیاری از موارد درخت تجزیه شده،‌ محصول نهایی نیست. ورودی تجزیه شده اغلب به مصرف یک مترجم می‌رسد که آن را به فرمت دیگر تبدیل می‌کند. کامپایلر برای تبدیل کد منبع ورودی به کد ماشین نهایی، در ابتدا ورودی را به درخت تجزیه شده تبدیل می‌کند و سپس آن را به کد ماشین ترجمه می‌کند.

{% figure caption:"چرخه‌ی تالیف کد ماشین" %}
![چرخه‌ی تالیف کد ماشین](/assets/images/content/2015/12/parsing-compilation-flow.png)
{% endfigure %}

#### تعاریف ثابت برای لغات و قواعد

لغات معمولا به صورت [عبارات باقاعده](http://www.regular-expressions.info/) (regular expressions) بیان می‌شوند. برای مثال زبان ما به صورت زیر تعریف می‌شود.
{% endcontainer %}

{% prism bash %}
INTEGER: 0|[1-9][0-9]*
PLUS: +MINUS: -
INTEGER: 0|[1-9][0-9]*PLUS: +
MINUS: -
{% endprism %}

{% container %}
همان طور که می‌بینید، اعداد به صورت عبارات باقاعده تعریف شده اند.

قواعد نحوی عموما به صورت فرمتی که آن را [BNF](http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form) می‌نامند تعریف می‌شوند. بر اساس این فرمت، زبان ما به این صورت تعریف می‌شود:
{% endcontainer %}

{% prism bash %}
expression :=  term  operation
term operation :=  PLUS | MINUS
term := INTEGER | expression
{% endprism %}

{% container %}
در مثال بالا ما گفته‌ایم که این زبان می‌تواند توسط تجزیه‌گرهای معمول تجزیه شود؛ اگر گرامر آن یک گرامر با چارجوب آزاد ([context free grammer](http://en.wikipedia.org/wiki/Context-free_grammar)) باشد. در یک تعریف سر راست، به گرامری، گرامر با چارچوب آزاد می‌گویند که بتوان آن را به صورت کامل توسط فرمت BNF بیان کرد.

####انواع تجزیه‌گرها

دو نوع تجزیه‌گر وجود دارد: تجزیه‌گر بالا به پایین و بر عکس. در یک تعریف کل، تجزیه‌گر بالا به پایین ساختار سطح بالای از قواعد را می‌سنجد و سعی می‌کند تا قاعده منطبق با آن را پیدا کند. در حالی که در تجزیه‌گر پایین به بالا، تجزیه‌گر با ورودی‌ها شروع می‌کند و خُرد خُرد شروع به تبدیل آن‌ها به قواعد نحوی می‌کند؛ یعنی از قواعد سطح پایین شروع می‌کند تا برسد به قواعد سطوح بالاتر. بیاید ببینیم این دو نوع تجزیه‌گر در مواجه با زبان چگونه عمل می‌کنند.

تجزیه‌گر بالا به پایین، از قواعده‌ای با بالاترین سطح شروع می‌کند: آن داده‌های 3 + 2‌ را به عنوان یک عبارت  شناسایی می‌کند. سپس به نوبت به شناسایی ۱ - ۳ +‌۲ می رسد که به عنوان عبارتی دیگر شناسایی شود (فرآیند شناسایی عبارات به صورت تدریجی‌، با تطابق دادن با قواعد دیگر است؛ اما نقطه شروع این سنجش قاعده‌ای با بالاترین مرتبه است).

تجزیه‌گر پایین به بالا، شروع به اسکن ورودی می‌کند تا زمانی که یکی از قواعد منطبق شود. سپس ورودی را با قاعده‌ی منطبق جایگزین می‌کند. این کار را تا جایی ادامه می‌دهد که به انتهای رشته‌ی ورودی‌ برسد. عبارات منطبق موقتی در پشته‌ی تجزیه‌گر قرار می‌گیرند.

{:.ltr}
| Stack | Input |
| --- |:---:|
|   | 2 + 3 - 1 |
| term | + 3 - 1 |
| term operation | 3 - 1 |
| expression | - 1 |
| expression operation | 1 |
| expression | - |

این نوع از تجزیه‌گرهای بالا به پایین، تجزیه‌گرهای شیفیتی-کاهشی (shift-reduce) هم نامیده می‌شوند. چون ورودی به سمت راست شیفت داده می‌شود (تصور کنید که اشاره‌گر ابتدا به اولین مقدار ورودی اشاره می‌کند و بعد به سمت راست حرکت می‌کند) و به تدریج قواعد نحوی را تولید می‌کند.

####ایجاد خودکار تجزیه‌گرها

ابزارهای وجود دارند که می‌توانند یک تجزیه‌گر تولید کنند. به این صورت که شما به آنها گرامر زبان خود را می‌خورانید-گرامری که شامل دایره واژگان و قواعد دستوری است- و آن‌ها برای شما یک تجزیه‌گر واقعی ایجاد می‌کنند. ساختن یک تجزیه‌گر نیازمند درک بالایی از تجزیه‌گرهاست که در نوع خودش کار چندان ساده‌ای نیست ساختن یکی از آنها با دست خالی که بهینه نیز باشد. بنابراین ایجاد کننده‌ی تجزیه‌گرها ابزاری بسیار مفیدی در نوع خود هستند.

وب‌کیت از دو ایجاد کننده‌ی خودکار تجزیه‌گرها استفاده می‌کند که عبارتند از: **فِلِگس** ([Flex](http://en.wikipedia.org/wiki/Flex_lexical_analyser)) برای ساختن لِگزر و **بایسِن** [Bison](http://www.gnu.org/software/bison/) برای ساختن یک تجزیه‌گر (که شاید اسم آنها تحت عنوان Lex و Yacc به گوشتان خورده باشد). ورودی ورودی فلگس فایلی است که متشکل شده از عبارات باقاعده‌ای که تُکن‌های معتبر را تعریف کرده است. ورودی بایسن هم تشکیل شده از قواعد دستوری زبان که به فرمت BNF در آمده‌اند.

###تجزیه‌گر HTML

کار این تجزیه‌گر این است که دستورات HTML را به درخت تجزیه تبدیل کند.

#### گرامر تعریف شده‌ی زبان HTML

واژگان و قواعد دستوری زبان HTML توسط سازمان W3C در [مستندات](http://www.w3.org/TR/html5/syntax.html) کامل این زبان آورده شده است.

#### گرامر HTML از نوع قالب آزاد نیست!

همان طور که در معرفی تجزیه‌گرها شاهد بودید، قواعد گرامری می‌توانند به شکلی تعریف شوند که از فرمت‌های نظیر BNF است کنند. متاسفانه هیچ یک از تجزیه‌گرهای معمول بحث شده در فصل قبلی را نمی‌توانیم برای تجزیه‌ی HTML‌ استفاده کنیم (من فصل قبل را صرفاً برای سرگرمی نیاوردم-از آن مفاهیم در فصل‌های بعدی در شرح تجزیه‌گرهای CSS و جاوااسکریپت استفاده خواهیم کرد). گرامر مورد نیاز تجزیه‌گرها برای HTML را نمی‌توان به راحتی توسط گرامرهای بدون چارچوب تعریف کرد.

یک فرمت مشخص برای تعریف گرامر HTML‌ وجود دارد به نام DTD (Document Type Definition)؛ اما آن یک گرامر با چارچوب آزاد نیست. قبول دارم که این موضوع شاید در نگاه اول کمی عجیب به نظر برسد؛ زیرا HTML چیزی شبیه به XML‌ است. و خب تجزیه‌گرهای زیادی برای XML‌ وجود دارد! حتی یک نوع خاصی هم از HTML وجود دارد که به آن XHTML می‌گویند! پس تفاوت در چیست؟

تفاوت در این است که HTML زیادی «بخشنده (forgiving)» است! به طوری که او به شما خورده‌ای نمی‌گیرد اگه یادتان یکی از تگ‌های اصلی را جا بیندازید (مانند HEAD)، یا یادتان برد تگی را ببندید یا باز کنید و به همین منوال. به عبارتی HTML‌ دارای یه قاعده دستوری نرم است، برخلاف آن چیزی که در XML‌ اتفاق می‌افتد.

همین اختلاف به ظاهر جزیی، باعث یک دنیا اختلاف شده است. از سوی دیگر، همین تفاوت است که باعث محبوبیت HTML شده است. او اشتباهات شما را نادیده می‌گیرد و زندگی را برایتان شیرین! و البته از سوی دیگر نوشتن یک گرامر مشخص را بسیار سخت می‌گرداند.

####HTML DTD

گرامر HTML در قالب DTD تعریف می‌شود. این قالب برای تعریف زبان‌های خانواده‌ی [SGML](http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language) استفاده می‌شود. این قالب شامل تعاریف تمامی عناصر مجاز به همراه خصوصیات و فرزندانشان است.

####DOM

خروجی درخت تجزیه، درختی است به نام درخت عناصر DOM و خصوصیات آن‌ها. DOM‌ اختصار شده‌ی Document Object Model است. این شی بیان کننده‌ی و نمایش‌دهنده‌ی سند HTML و رابط عناصر آن به دنیای بیرون مانند جاوااسکریپت است. به عبارتی با این شی است که سند HTML و عناصر آن معنی می‌یابند و می‌توانند با لایه‌های دیگر ارتباط برقرار کنند.

ریشه‌ی درخت DOM، شی «Document» است. که تمامی اجزای دیگر از آن ریشه گرفته‌اند. DOM یک رابطه یک-به-یک نسبت به مارک‌آپ خود دارد. برای مثال:
{% endcontainer %}

{% prism html %}
<html>
  <body>
     <p>Hello World</p>
     <div><img src="example.png"/></div>
  </body>
</html>
{% endprism %}

{% container %}
مارک‌آپ فوق وقتی به درخت DOM‌ تبدیل شود، به شکل زیر در می‌آید:

{% figure caption:"درخت DOM تشکیل شده از مارک‌آپ مثال قبلی" %}
![درخت DOM تشکیل شده از مارک‌آپ مثال قبلی](/assets/images/content/2015/12/dom-tree-of-html-markup.png)
{% endfigure %}

#### الگوریتم تجزیه HTML

همان‌طور که در بخش قبلی دیدیم، HTML‌ را نمی‌شود با تجزیه‌گرهای معمول بالا به پایین یا پایین به بالا تجزیه کنیم. بنا به این دلایل:

1. ذات سخاوتمند HTML.
2. این حقیقت که مرورگرها دارای یک مکانیزم سنتی چشم‌ پوشی از خطا هستند برای پشتیبانی موارد شناخته شده از دستورات نامعتبر HTML.
3. فرآیند تجزیه‌ HTML‌ متاثر از منابع مختلف است؛ در صورتی که در زبان‌های دیگر منبع در طول مدت تجزیه و تبدیل محفوظ و بدون تغییر می‌ماند. این در حالی است که HTML با دارا بودن کدی پویا، که هر لحظه ‌می‌تواند تحت تاثیر یک عنصر بیرونی (مانند یک عنصر script‌ که شامل فراخوانی متد write از شی document باشد ()document.write) قرار بگیرد و با اضافه شدن یک تُکن خارجی، نتیجتاً باعث این می‌شود فرآیند تجزیه‌گر ورودی را تغییر دهد.

ناتوانی در استفاده از تجزیه‌گرهای معمول باعث این شده است که مرورگرها خودشان دست به کار شوند و دسته به ساختن تجزیه‌گرهای HTML مختصص خودشان بزنند. [نمونه‌ای از این الگوریتم‌های تجزیه‌گر با جزییات در توسط مستندات HTML5 توضیح داده شده است](http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html).

این الگوریتم از دو بخش تشکیل شده است: علامت گذاری (tokenization) و درخت ساختار (tree construction).

علامت گذاری همان بررسی لِگزیکال‌ها است؛ تجزیه ورودی‌ها به تُکن‌ها. از جمله‌ی تُکن‌های HTML می‌توان به تگ‌های شروع و پایان، خصوصیت‌ها (attributes) و مقادیر خصوصیت‌ها اشاره کرد.

علامت‌گذار، تُکنی را شناسایی می‌کند و بعد آن را به درخت ساختار می‌دهد. این چرخه تا جای تکرار می‌شود که تمامی ورودی‌ها علامت‌گذاری و در درخت جانمایی شده باشند.

{% figure caption:"چرخه‌ی تجزیه‌ی HTML" %}
![چرخه‌ی تجزیه‌ی HTML](/assets/images/content/2015/12/html-parsing-flow.png)
{% endfigure %}

#### عملیات صورت گیرنده بعد از اتمام تجزیه HTML

در این مرحله مرورگر شی document را به عنوان شی قابل تعامل نشانه‌گذاری می‌کند (این دقیقا همان لحظه است که رخداد [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) توسط مرورگر فراخوانی می‌شود) و اسکریپت‌های که به صورت «deferred» نشان‌گذاری شده اند اجزای اجرا پیدا می‌کنند (اسکریپت‌های که دارای این خصوصیت هستند، ملزم هستند تا انتهای تجزیه سند منتظر بمانند و سپس اجرا شوند. یعنی اجازه ندارند جلوی اجرای تجزیه‌گر و لود DOM را سد کنند). بعد از اجرای این اسکریپت‌ها حالت سند به «complete» تغییر کرده و مطابق آن رخداد «[load](https://developer.mozilla.org/en-US/docs/Web/Events/load)» فراخوانی می‌شود.

#### چشم پوشی از خطا در مرورگرها

مرورگر هیچ گاه خطای «Invaild Syntax» (خطای نحوی) در هنگام اجرای یک سند HTML نشان نخواهد داد. آن‌ها فروتنانه، تمامی خطاهای موجود را برطرف می‌کنند و به کارشان ادامه می‌خواند داد بدون اینکه مزاحم شما شوند!

به عنوان مثال این کد HTML‌ را در نظر بگیرید:
{% endcontainer %}

{% prism html %}
<html>
  <mytag></mytag>
  <div>
    <p>
  </div>
      Really lousy HTML
  </p>
</html>
{% endprism %}

{% container %}
در کد بالا من از چند قاعده تخطی کرده‌ام («mytag» یک تگ استاندارد نیست، رعایت نکردن تقدم سطوح در تگ‌های «div» و «p» و موارد دیگر) ولی با این حال مرورگر هم‌چنان شکایتی ندارد و حتی به صورت درست سند را نمایش می‌دهد!

مدیریت خطاها یکی از اصول ثابت و اولیه در مرورگرها است، این در حال است که هیچ کدام از این قواعد در کمال تعجب جز خصوصیات ذاتی تدوین شده‌ی برای HTML نیست! مانند بوکمارک کردن و دکمه‌های عقب و جلو،‌ این هم همانند آنها سال‌های متمادی که به صورت پیش‌فرض توسط توسعه دهندگان مرورگرها پشتیبانی می‌شود. البته HTML5 تعدادی از این پیش‌نیاز‌ها را برای مدیریت خطا نحوی در مستندات خویش آورده است.
###تجزیه CSS

مفاهیم گفته شده درباره‌ی تجزیه‌ی داده‌ها را که گفته شد یادتان هست؟ خب، برخلاف HTML، گرامر زبان CSS جزئ گرامرهای بدون چارچوب محسوب ‌می‌شود و به وسیله‌ی همان نوع تجزیه‌گرهای که برایتان شرح دادم قابل تجزیه است. در حقیقت [قواعد دستوری و واژگان CSS](http://www.w3.org/TR/CSS2/grammar.html) به طور مشخص و ثابت در مستندات آن آورده شده است. حالا اگر علاقه‌مند بودید که بفهمید دقیقا رفتار این تجزیه‌گر چگونه است و چطور دستورات را تجزیه می‌کند؛ می‌توانید به [این‌جا](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#CSS_parsing) یک سری بزنید.

####تجزیه‌گر CSS موتور وب‌کیت

دیدیم که وب‌کیت از دو ایجاد کننده‌ی خودکار پارسر به نام‌های فلیگس و بایسون برای ساختن خودکار تجزیه‌گرها از فایل‌های گرامر زبان CSS استفاده می‌کند. اگر به یاد داشته باشید، گفتیم که بایسون یک پارسر پایین به بالای شیفتی-کاهنده می‌سازد؛ اما در مقابل فایرفاکس از یک پارسر بالا به پایین که خودش درست کرده استفاده می‌کند. در هر دو مورد، فایل CSS به یک شی StyleSheet تجزیه و تبدیل می‌شود. هر کدام از اشیا در بر گیرنده‌ی قواعد CSS هستند. این اشیای قواعد CSS علاوه‌ بر اینکه شامل اشیای انتخابگرها (selector) و خصوصیاتشان (declaration) هستند شامل دیگر اشیای مرتبط-شان در گرامر CSS نیز می‌شوند. شکل زیر به طور کامل گویای آن چیزی که به چه چیزی یک شی StyleSheet‌ می‌گوییم و آن دربردارنده‌ی چه اشیایی است.

{% figure caption:"درخت حاصل از تجزیه‌ی CSS" %}
![درخت حاصل از تجزیه‌ی CSS](/assets/images/content/2015/12/parsing-css-style-tree.png)
{% endfigure %}

### ترتیب پردازش اسکریپت‌ها و استایل شیت‌ها

#### اسکریپت‌ها

(نکته: زین پس ما به جای synchronous خواهیم گفت: **ترتیبی** و به جای asynchronous می‌گوییم: **موازی**)

فرآیند کلی پردازش در وب، به صورت ترتیبی و پشت سر هم است. توسعه دهندگان انتظار دارند که اسکریپت‌ها به محض اینکه تجزیه‌گر به تگ آغازین `<script>` می‌رسند، تجزیه و اجزا شوند. به همین دلیل تجزیه‌گر ducument تا زمانی که اجرای اسکریپت به پایان برسد متوقف خواهد ماند. در صورتی هم که اسکریپت از نوع خارجی باشد که به یک فایل بیرونی ارجاع داده شده باشد، تجزیه گر باید صبر کند تا داده‌ها اسکریپت از طریق لایه‌ی شبکه دریافت و تحویل داده شود تا بعد از تجزیه و اجرای اسکریپت، تجزیه‌گر اصلی HTML دوباره کارش را ادامه دهد. که خود این عمل دریافت داده‌ها از لایه شبکه هم پردازشش به صورت ترتیبی خواهد بود. این مدل از فرآیند پردازشی برای سالیان زیادی که وجود دارد و در مستندات نسخه‌های ۴ و ۵ HTML شرحش هم آمده است.

توسعه دهندگان در مواجه با این مشکل، آنقدرها هم بی‌چاره نیستند و می‌توانند با اضافه کردن خصوصیت «defer» به تگ script از متوقف شدن تجزیه‌گر HTML جلوگیری کنند و اجرای اسکریپت را به بعد از پایان یافتن کامل دریافت و تجزیه‌ی HTML موکول کنند. ولی با این حال آن مشکل دریافت داده‌های اسکریپت‌های خارجی به صورت یک فرآیند ترتیبی همچنان به قوت خود باقی بود که با آمدن HTML5 و اضافه شدن خصوصیت «async» به آن این مشکل هم تا حدودی مرتفع شد. اسکریپت‌های که دارای این خصوصیت باشند دیگر توسط مرورگر در یک جریان (thread) جداگانه‌ای به صورت موازی با جریان‌های پردازشی دیگر دریافت و تجزیه می‌شوند.

####تجزیه‌‌‌ی موازی

هر دوی موتورهای وب‌کیت و گِکو عمل تجزیه موازی را به صورت بهینه‌ای انجام می‌دهند. وقتی که اسکریپتی در حال اجرا است، جریان‌های دیگر کار تجزیه‌ی و ترجمه مابقی HTML‌ را ادامه می‌دهند تا بفهمند که چه منابعی نیاز دارند که از لایه شبکه دریافت و بارگذاری شوند؛ تا آن‌ها را بارگذاری کنند. در این روش، منابع می‌توانند به صورت خطوط ارتباطی موازی از هم دریافت و بارگذاری شوند که نتیجتاً این امر باعث کاهش زمان برگزاری کل صفحه می‌شود. به همین دلیل هم به این روش تجزیه‌ی موازی می‌گویند.

البته توجه داشته باشید که این موضوع تجزیه‌گرهای موازی، تنها به تجزیه‌گرهایی مربوط می‌شود که به منابع خارجی مانند اسکریپت‌ها، استایل‌ شیت‌ها، تصاویر و فونت‌های اشاره دارند که درخت DOM را تغییر نمی‌دهند! - یعنی تجزیه‌گر اصلی HTML بدون توجه به فرآیند دریافت و بارگذاری آن‌ها می‌توانند کار خودش را انجام دهد؛ و کاری به کار هم نداشته باشند و هر کدام به طور مستقل بتوانند کارشان را به پایان ببرند.

#### استایل شیت‌ها
از سوی دیگر برای پردازش استایل شیت‌ها نسبت به اسکریپت‌ها از مدل پردازشی دیگر استفاده می‌شود. شاید بگویید که، از آنجایی که استایل شیت‌ها نمی‌توانند تغییری در درخت DOM بدهند، دلیلی ندارد که منتظر آنها بمانیم و اجازه بدهیم که کار تجزیه HTML را مختل کنند و جلوی آن را بگیرند! بله از نظر مفهومی حق با شماست، ولی اینجا یه مشکل هست؛ آن هم زمانی که یک اسکریپت درخواست اطلاعاتی از استایل شیت‌ها داشته باشد در زمانی که فرآیند اصلی تجزیه‌ی HTML در حال اجرا است. اگر اطلاعات استایلی خواسته شده هنوز دریافت و تجزیه نشده باشند، در خوش بینانه‌ترین حالت اگه فرآیند اجرای اسکریپت متوقف نشود، باید انتظار یک جواب غلط از سمت آن را داشته باشیم.

این مسئله شاید به نظر یک مورد خاص به نظر برسد که احتمال وقوع آن خیلی نادر باشد، ولی تجربه نشان داده که برعکس، خیلی هم رایج است. برای جلوگیری از وقوع همچین مشکلاتی، فایرفاکس تر و خشک را باهم می‌سوزاند. یعنی تا زمانی که تمامی استایل شیت‌های صفحه دریافت و تجزیه نشده باشند، اجرای تمامی اسکریپت‌ها را متوقف می‌کند؛ حتی آن‌هایی که کاری به کار استایل شیت‌ها نداشته باشند. اما وب‌کیت با انصاف‌تر عمل می‌کند و تنها جلوی اجرای اسکریپت‌هایی را می‌گیرد که نیاز به اطلاعات استایل شیت‌هایی داشته باشند که هنوز بارگذاری نشده‌اند.

### ساختمان درخت رندر

زمانی که درخت DOM تکمیل شد، مرورگر شروع به ایجاد درختی دیگر، به نام درخت رندر می‌کند. گره‌های تشکیل دهنده‌ی این درخت، عناصر گرافیکی صفحه هستند. این عناصر درست به همان ترتیبی که در صفحه نمایش باید ظاهر شوند، از بالا به پایین بر روی درخت رندر جاگذاری می‌شوند. هدف از تشکیل این درخت، آسان کردن لایه‌ی رنگرزی است که با کمترین دردسر بتواند با ترتیب درست به نقاشی عناصر تشکیل دهنده‌ی صفحه بپردازد.

 فایرفاکس به این عناصر گرافیکی و به نوعی گره‌های درخت رندر، «فریم» می‌گوید. در حالی که وب‌کیت از لفظ «رندر شده‌ها» یا «اشیای رندر» برای آن‌ها استفاده می‌کند.

یک شی رندر می‌داند که چطور خود و بچه‌هایش را نقاشی و صفحه بندی (لایه بندی؛ اینکه جایگاهش در صفحه از نظر طول و عرض دقیقا کجای صفحه است) کند.  

کلاس RenderObject وب‌کیت که کدش را قسمت زیر مشاهده می‌کنید، کلاس پایه‌ی همین اشیای رندر یا فریم‌ها هستند:
{% endcontainer %}

{% prism javascript %}
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;`...`  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
{% endprism %}

{% container %}
هر شی رندر دارای یک ناحیه‌ی مستطیلی شکل فرضی است که نشان دهنده‌ی همان CSS box معروف است که در CSS2 اضافه شده است (برای دیدن این مستطیل در مرورگر خود کافی است خاصیت outline عنصر مورد نظرتان را با مقدار «1px solid red» مقدار دهی کنید). این جعبه همان طور که گفته شد شامل اطلاعات هندسی مانند طول و عرض و موقعیت عنصر در صفحه است.

نوع جعبه نیز متاثر از مقدار خصوصیت "display" استایل عنصر مورد نظر است که مطابق است با گره‌ی متناظرش. در قطعه کد زیر که از موتور وب‌کیت استخراج شده، موتور بر اساس آن تصمیم می‌گیرد که چه نوع شی رندری باید برای گره‌ی متناظر DOM-اش بر اساس خصوصیت "display" آن ساخته شود:
{% endcontainer %}

{% prism javascript %}
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;
    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }
    return o;
}
{% endprism %}

{% container %}
###رابطه درخت رندر نسبت به درخت DOM

اشیای رندر یا همان فریم‌ها با گره‌های درخت DOM در ارتباط هستند؛ ولی رابطه‌ی آن از نوع یک-به-یک نیست. عناصر غیر-بصری DOM (همان‌های که در صفحه نمایش داده نمی‌شوند و مقدار "display" آنها برابر با "none" است) در درخت رندر آورده نمی‌شوند. مانند عنصر "head" که همیشه مخفی است (مقدار خصوصیت "display" تگ "head" به صورت پیش فرض برابر با "none"‌ است). اما این برای عناصر که خصوصیت "visibility" آن‌ها برابر با "hidden" هست، صدق نمی‌کند و این عناصر در درخت رندر آورده می‌شوند.

عناصری از DOM هستند که به طور هم‌زمان به چند عنصر گرافیکی در ارتباط هستند. این عناصر معمولا دارای ساختار پیچیده‌ای هستند که نمی‌شود آنها را تنها با یک جعبه هندسی تنها توصیف کرد. مانند عنصر "select" که خود به ۳ شی رندر مرتبط است؛ که عبارتند از: یکی برای ناحیه نمایشی (مستطیل اصلی)، یکی برای لیست باز شونده (همان "drop down") و یکی نیز برای دکمه. و البته وقتی که متن هر یک از موارد لیست یا دکمه به خاطر نامنایب بودن عرض تعیین شده برایش به چند خط بشکند برای هر خط درخت رندر یک شی رندر در نظر می‌گیرد.

مثالی دیگر از این عناصر چند شی ای می‌توان به استفاده‌ی نا به جای عناصر HTML اشاره کرد. طبق مستندات CSS یک عنصر "inline" یا باید در بر گیرنده‌ی فقط یک عنصر از نوع "block" باشد یا فقط از نوع "inline". در صورتی که از مخلوط این دو نوع باهم در درون آن استفاده شود باعث این می‌شود که یک شی "block" بی نام و نشان ایجاد شود که عناصر "inline"‌ را در بر گرفته است (اصطلاحاً  آن‌ها را "wrap" می‌کند).

بعضی از اشیای رندر (فریم) هم هستند که به یک گره از DOM مرتبط شده‌اند؛ ولی نه به همان ترتیبی که در درخت رندر قرار دارند. عناصر "float" و  "absolute"-ای که خارج از جریان کلی صفحه موقعیت دهی شده باشند؛ در جای دیگری از آنجایی که باید باشند در درخت رندر جانمایی می‌شوند.  

{% figure caption:"درخت رند و درخت DOM متناظر با آن. 'Viewport' یک بلاک در برگیرنده‌ای اولیه است که به صورت پیش فرض فراخوانی می‌شود. در وب‌کیت آن به عنوان یک شی 'RenderView' شناخته می‌شود" %}
![the-render-tree-and-the-corresponding-dom-tree](/assets/images/content/2015/12/the-render-tree-and-the-corresponding-dom-tree.png)
{% endfigure %}

#### فرآیند ساخت درخت رندر

در فایرفاکس، ایجاد کننده درخت رندر به عنوان یک منتظر (listerner) برای آپدیت‌های DOM عمل می‌کند. به طوری که او عمل ساختن فریم را به متد اصلی سازنده فریم "FrameConstructor" محول ("delegate") می‌کند و این متد سازنده است که استایل‌ها را محاسبه می‌کند (ببینید قسمت محاسبه استایل را)و فریم را تشکیل می‌دهد.

در وب‌کیت، فرآیند محاسبه استایل و تشکیل شی‌های رندر، «ضمیمه» "attachment" نامیده می‌شود. هر گره‌ی DOM یک متد «ضمیمه» دارد. فرآیند اجرای ضمیمه هم به صورت ترتیبی است؛ به این طور که وقتی گره‌ای به درخت DOM اضافه می‌شود، متد ضمیمه‌ی گره‌ی تازه از راه رسیده فراخوانی می‌شود.

نتیجه‌ی پردازش دو تگ "html" و "body" صفحه موجب ساخت گره‌ی ریشه‌ی درخت رندر می‌شود. شی ریشه‌ی درخت طبق آن چیزی که در مستندات رسمی CSS آمده است، یک بلوک در بر گیرنده با این تعریف: بلوکی با بالاترین سطح، که در بر گیرنده‌ی تمامی بلوک‌ها موجود در صفحه است؛ نامیده می‌شود. از طرفی هم این همان بلوکی است که به شی "viewport" ابعاد می‌دهد (منظور همان ابعاد ناحیه است پنجره نمایش مرورگر در صفحه نمایش اشغال کرده است). فایرفامس این بلوک را "ViewPortFrame" می‌خواند و وب‌کیت نیز آن را "RenderView". این شی دقیقا همان شی است که گره‌ی "document" از درخت DOM به آن اشاره می‌کند. مابقی درخت رندر هم به عنوان گره‌های بعد درخت DOM در زیر این این گره به درخت اضافه می‌شوند.

####محاسبه‌ی استایل

لازمه‌ی ساختن درخت رندر، محاسبه‌ی خصوصیات گرافیکی هر کدام از اشیای درخت رندر است؛ که این امر از طریق محاسبه‌ی تک تک خصوصیات استایلی مربوط هر عنصر صفحه قابل حصول است.

وقتی می‌گوییم استایل، منظورمان کلیه‌ی صفحه‌هات استایلی است که از مبادی مختلف گرد آوری شده اند. این مبادی عبارتند از:‌ استایل‌های درونی عناصر "inline" (منظور هم آنهایی است که به صورت خصوصیت "style"‌ برای یک تگ تعریف می‌شوند و هم آنهایی که در داخل تگ `<style>` قرار می‌گیرند.)، خصوصیت‌های گرافیکی HTML (مانند "bgcolor")، فایل‌های CSS بیرونی و در نهایت استایل پیش‌فرضی که خود مرورگر تعریف کرده است که به آنها مصدر "origin" هم می‌گویند.

اصلا چرا می‌گوییم «محاسبه‌ی» استایل‌ها؟! نمی‌گوییم مثلا اضافه کردن استایل‌ها. به خاطر این‌که همان طور که بند قبلی گفته شد، استایل‌های یک عنصر از مبادی متعددی قابل حصول هستند که هر یک نسبت به دیگری اولویت خاصی دارد و از طرفی نحوه‌ی تعریف کردن قواعد استایل‌ها در صفحه‌هات استایلی نیز دارای ترتیب و نظم خاصی است که سطوحی از اولویت‌های مختلف را شامل می‌شود که همه‌ی این‌ها نیازمند یک سری محاسباتی ریاضی است تا ترتیب صحیح اعمال این استایل‌ها مشخص شود. به دلیل این پیچیدگی‌ها محاسبات استایل‌ها برای مرورگرها با مشکلات و سختی‌هایی همراه است که آنها عبارتند از:

1. داده‌های استایلی یک سازه‌ی عظیمی از ساختمان داده‌ها را ایجاد می‌کند که نگهداری این حجم عظیم از خصوصیات، بعضا در سایت‌های بزرگ باعث بروز مشکلات مربوط به کمبود حافظه (از نوع رَم) می‌شود.
2. پیدا کردن قواعد استایلی مربوط به هر عنصر در صورتی که بهینه نباشند، باعث بروز مشکلاتی در کارایی (منظور همان پرفورمنس است) بارگذاری صفحه می‌شود. پیمایش لیست کامل قواعد استایلی برای پیدا کردن عناصر بار پردازشی سنگینی بر دوش مرورگر می‌گذارد. انتخابگرها ("selector") می‌توانند از ساختار پیچیده‌ای داشته باشند که موجب شود در فرایند پردازش تعیین مسیر درست بر روی درخت DOM به مسیرهایی بر بخوریم که در ابتدا به نظر امید بخش و قایل حصول می‌رسند ولی در آخر معلوم شود که مسیر اشتباهی بوده و همین طور برعکس. برای مثال انتخابگر زیر بیاید بررسی کنیم:
{% endcontainer %}

{% prism css %}
div div div div {
  ...
}
{% endprism %}

{% container %}
انتخابگر بالا به این معنی است که قواعد مورد نظر باید به یک تگ "div" که خودش زیر مجموعه‌ی سه تگ "div"‌ است، اعمال شود. از آنجایی که انتخابگر‌ها از راست به چپ خوانده می‌شوند، ما در پایین‌ترین سطح درخت، یعنی برگ‌های به دنبال تمامی گره‌های "div" بگردیم و بعد آنهایی را نگهداریم که والدشان یک تگ "div" است؛ و این کار را تا جایی به سمت بالا ادامه می‌دهیم که تمام مسیر‌هایی که روی درخت مطابق با قاعده‌ی انتخابگر ما است، بدست آوریم. حالا مشکل جایی است که ما مسیری را می‌رویم که نهایتا به دو تگ تو در توی "div" یا ۳ تگ تو در تو می‌انجامد که خب، هیچ کدامشان قابل قبول نیست. همین رفتن و برگشتن‌های بی‌حاصل مرورگر وقتی تعداد انتخابگر‌های یک سایت بیش تر از چند صد تا باشد، باعث کاهش کارایی آن می‌شود.
3. پیچیدگی اعمال قواعد یا همان خصوصیات گرافیکی عناصر با درنظر گرفتن ترتیب و اولیت‌های تعریف شده برای قواعد. (همان مسائلی که کمی بالاتر در بندی که دلیل استفاده از لفظ محاسبات برای استایل‌ها شرح داده شد آمده است.)

خوش بختانه مرورگرها نرم‌افزارهای پرتلاش هستند و سعی کرده‌اند تا به [روش‌های](http://taligarsiel.com/Projects/howbrowserswork1.htm#Sharing_style_data) [مختلف](http://taligarsiel.com/Projects/howbrowserswork1.htm#Firefox_rule_tree) و با بهره بردن از [الگوریتم‌های](http://taligarsiel.com/Projects/howbrowserswork1.htm#Manipulating_the_rules_for_an_easy_match) [بهینه](http://taligarsiel.com/Projects/howbrowserswork1.htm#Applying_the_rules_in_the_correct_cascade_order) بر این مشکلات فایق بشوند؛ ولی شکی نیست که توسعه‌دهندگان باید به روش‌های ناصحیح و صحیح توسعه‌ی CSS تسلط کامل دشاته باشند تا بتوانند تا آنجایی که می‌توانند کار را برای مرورگر‌ها آسان‌تر کنند که در نهایت به کمک هم بتوانند یک تجربه‌ی فوق العاده برای کاربر رقم بزنند.

#### پردازش تدریجی و گام به گام
وب‌کیت از یک پرچم ("flag") برای نشان‌دار کردن تمامی صفحات استایلی (حتی imports) که به صورت کامل باگذاری شده است، استفاده می‌کند. اگر استایلی هنگام عملیات ضمیه کردن ("attaching") به طور کامل  بارگذاری نشده باشد، استایل پیش فرض اعمال می‌شود و وقتی که استایل بارگذاری شد، دوباره محاسبات مربوط به آن عنصر انجام می‌شود.

##صفحه بندی ("layout")

وقتی که اشیای رندر ایجاد شدن و به درخت رندر اضافه می‌شوند، هنوز اندازه ("size") و موقیعتشان ("position") در صفحه مشخص نشده است. محاسبه این مقادیر بر عهده‌ی قسمت صفحه بندی یا جانمایی ("reflow") است.

سند HTML از یک مدلی شبیه حرکت جریان رود ("flow") برای صفحه بندی استفاده می‌کند. بدان معنی که بیشتر اوقات آن ممکن است که محاسبات هندسی تنها در یک جهت صورت بگیرد (اشاره به جریان آب رودخانه دارد که تنها به یک سو و جهت شناور است). عناصری که بعداً به جریان صفحه اضافه ‌می‌شوند،‌از لحاظ مقادیر هندسی، عناصری که از قبل در جریان بوده‌اند تحت تاثیر قرار نمی‌دهند. به همین دلیل از آنجایی که جهت متون در HTML به خاطر زبان انگلیسی به طور پیش فرض چپ به راست در نظر گرفته شده است، این جریان صفحه بندی عناصر صفحه نیز تحت تاثیر آن به صورت چپ به راست و از بالا به پایین است.

سیستم مختصات دهی عناصر صفحه، وابسته به فریم ریشه است؛ که به طور پیش فرض مبدا آن در گوشه‌ی بالایی سمت چپ صفحه مرورگر است در زبان‌های چپ به راست. این نقطه با مختصات 0,0 مشخص می‌شود.

فرآیند پردازشی مربود به صفحه بندی به صورت بازگشتی است. این فرآیند از شی رندر ریشه که به تگ "html" اشاره می‌کند، شروع می‌شود و به صورت بازگشتی با پیمایش بعضی یا تمامی فریم‌های زیر مجموعه‌ای خود و محاسبه اطلاعات هندسی هر کدام از فریم‌ها که نیاز بود ادامه پیدا می‌کند. تمامی فریم‌ها دارای یک متد "layout" یا "reflow" هستند، که در صورت نیاز این وظیفه‌ی والد است که متد صفحه بندی فرزندانش را فراخوانی کند.

###سیستم کمی چِرک ("dirty bit")

صفحه بندی فرآیند پر هزینه‌ است، خصوصا برای دستگاه‌های که از منابع پردازشی پایین‌تری بهره می‌برند؛ مانند گوشی‌های همراه. مرورگر برای اینکه برای هر تغییر کوچکی در صفحه مجبور نشود که کلا صفحه را دوباره صفحه بندی کند، از سیستم «کمی/مقداری/ذره‌ای-چرک/کثیف/آلوده» استفاده می‌کند. این سیستم فریمی که تغییر می‌کند یا اضافه می‌شود به درخت رندر را، خودش و فرزندانش را به عنوان «کثیف» علامت گذاری می‌کند؛ که این یعنی، نیاز به صفحه‌بندی دارد این قسمت.

در کل دو پرچم در این سیستم وجود دارد: «کثیف» و «بچه‌هاش کثیفن»؛ که این دومی به این معنی که ممکن خود فریم تمیز باشه ونیازی به صفحه بندی مجدد نداشته باشه، ولی بچه‌هاش نیازمند صفحه‌بندی هستند.

###انواع صفحه بندی: تدریجی و عمومی

صفحه بندی می‌تواند بر کل درخت رندر اعمال شود؛ که به این نوع می‌گوییم، صفحه بندی عمومی ("global"). این نوع در صورتی که موارد زیر اتفاق بیفتند، اعمال می‌شود:

1. یکی از استایل‌های عمومی تغییر کند. مثلا اگه اندازه‌ی فونت تغییر کند، تمامی فریم‌ها تحت تاثیر قرار می‌گیرند.
2. در صورتی که پنجره مرورگر تغییر سایز بدهد.

اگه فریمی کثیف شود، صفحه بندی به صورت تدریجی ("incremental") خواهد بود. این نوع صفحه بندی به صورت موازی ("asynchronously") بر فریم‌ها اعمال می‌شود. برای مثال وقتی که یک فریم جدید به درخت رندر اضافه می‌شود، فرآیند صفحه بندی صبر می‌کند تا اگر محتوای دیگری هم از لایه شبکه قرار است برسد به طور کامل بارگذری و به درخت DOM‌ اضافه شود و بعد فریم‌ جدید را صفحه بندی می‌کند.

 {% figure caption:"صفحه بندی تدریجی - تنها فریم‌های کثیف و فرزندانشان صفحه بندی می‌شوند." %}
![Incremental-layout](/assets/images/content/2015/12/Incremental-layout.png)
{% endfigure %}

###صفحه بندی ترتیبی و موازی

همان طور که اشاره شد، صفحه بندی تدریجی به صورت موازی ("asynchronously") اعمال می‌شود. فایرفاکس دستورات باز نشانی را برای اعمال صفحه بندی تدریجی صف بندی می‌کند و با تعیین یک زمان بندی به صورت دسته‌ای اقدام به اعمال این دستورات بر روی فریم‌ها می‌کند. در مقابل ، وب‌کیت نیز از دارای یک تایمر است که صفحه بندی تدریجی را اجرا می‌کند - به این صورت که درخت رندر را برای پیدا کردن فریم‌هایی که کثیف شده اند پیمایش می‌کند.

وقتی که اسکریپتی در زمان اجرا، درخواست اطلاعات نظیر مقدار "offsetHeight" را از درخت استایل بکند، موجب این می‌شود که صفحه بندی دیگر نتواند به صورت موازی اعمال شود؛ و در این حالت باید به صورت ترتیبی ("synchronously") انجام گیرد. صفحه بندی‌های عمومی هم معمولا به صورت ترتیبی اعمال می‌شوند. نتایج این نوع تغییرات عمومی اصلا خوش آیند مرورگر نیست، خصوصا در دستگاه‌ی همراه که نیاز دارند تا تغییرات را در فریم ۶۰ ثانیه‌ای اعمال کنند که کاربر هنگام مرور صفحات دچار مشکل نشود. اگر عمر باقی بود سعی می‌کنم در آیند بیشتر در این بار بنویسم. برای آشنایی بیشتر با [فرآیند صفحه بندی](http://taligarsiel.com/Projects/howbrowserswork1.htm#The_layout_process) و [نحوه محاسبات هندسی عناصر](http://taligarsiel.com/Projects/howbrowserswork1.htm#Width_calculation) به این پیوند‌ها مراجع کنید.

##رنگرزی ("painting")

در این مرحله درخت رندر، گره به گره پیمایش می‌شود و با فراخوانی متد "paint" هر فریم باعث می‌شود که محتوای این گره‌ها بر روی صفحه نمایش رسم و نقاشی شود. لایه‌ی رنگرزی از کلاس‌های رابط کاربری سیستم عامل استفاده می‌کند.

###انواع فرآیندهای رنگرزی: عمومی و تدریجی

همانند لایه‌ی صفحه بندی، لایه‌ی رنگرزی هم می‌توانند به صورت عمومی - وقتی کل درخت رندر نقاشی شود - و نیز تدریجی رخ دهد. رنگرزی تدریجی وقتی اعمال می‌شود که تغییر رخ داده تنها بر برخی از گره‌های درخت رندر تاثیر گذاشته باشد، نه بر کل درخت.

با تغییر کردن یک فریم، ناحیه‌ی مستطیلی آن بر روی صفحه نمایش غیر معتبر می‌شود (شما همان حالت کثیف شدن در صفحه بندی را در نظر بگیرید) که این امر موجب می‌شود که سیستم عامل با دیدن یک «منطقه‌ی آلوده» رخداد رنگرزی را فراخوانی کند. سیستم عامل این عمل را بسیار هوشمندانه انجام می‌دهد؛ به این ترتیب که سعی می‌کند تا آنجایی که امکان دارد این مناطق را در هم ادغام کند تا از بار پردازشی بکاهد. وقتی فریمی تغییر می‌کند، پیامی حاوی نشانی محدوده‌ی آلوده شده به ریشه درخت رندر فرستاده می‌شود و پیمایش درخت برای پیدا کردن گره‌ی آلوده شده شروع می‌شود تا زمانی که گره‌ی مورد نظر پیدا شود و متد "paint"-اش (و در صورت نیاز فرزندانش نیز) برای رنگرزی دوباره فراخوانی شود.

در مرورگر کروم این عملیات از این هم پیچیده‌تر است؛ زیرا فرآیند جداگانه‌ای از فرآیند اصلی برای این کار در نظر گرفته شده است. مدیریت این فرآیند به کل بر عهده‌ی پردازنده‌ی واحد گرافیکی ("GPU") در سیستم است، که مسول این چنین فرآیندهایی است. برای به کار گیری این پردازنده، کروم با کمی تغییرات تقریبا رفتار سیستم عامل را شبیه سازی کرده و مانند آن عمل می‌کند در کنترل این پردازنده. قبل از رنگرزی مجدد، وب‌کیت وضعیت ناحیه آلوده را قبل از آلوده شدن به صورت یک تصویر "bitmap" ذخیره می‌کند؛ و سپس با مقایسه تصاویر قبل و بعد از آلودگی، تنها نواحی را که آلوده شده اند؛ مجدد اقدام به رنگرزی می‌کند.

### ترتیب اولویت رنگرزی

[در مستندات CSS2 فرآیند رنگرزی الویت بندی شده است](http://www.w3.org/TR/CSS21/zindex.html) . به موجب این اولویت بندی، فرآیند رنگرزی از عقب ترین بلوک آغاز می‌شود تا به جلویی ترین بلوک برسد (جلویی ترین بلوک، نزدیک‌ترین بلوک به کاربر است در صفحه نمایش؛ از همان سیستم "z-index" پیروی می‌کند). اولویت بندی بلوک‌های هر فریم به صورت زیر است:

1. رنگ پس زمینه
2. تصویر پس زمینه
3. حاشیه ("border")
4. فرزندان
5. نوار بیرونی ("outline")

{% endcontainer %}
